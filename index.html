<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel Cat Survivor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --primary: #ff9900;
            --secondary: #2d2d2d;
            --accent: #00ffcc;
            --danger: #ff3333;
            --ui-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: var(--ui-font);
            user-select: none;
        }

        /* Canvas container */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas usually */
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #hud-top-left {
            top: 20px;
            left: 20px;
        }

        #hud-top-right {
            top: 20px;
            right: 20px;
            text-align: right;
        }

        #xp-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 20px;
            background: #333;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #xp-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffcc);
            transition: width 0.2s;
        }

        #level-indicator {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* Screens (Start, Game Over, Level Up) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            color: var(--primary);
            margin-bottom: 10px;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #fff;
            letter-spacing: 2px;
            text-align: center;
        }
        
        h2 {
            color: white;
            font-size: 2rem;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.4);
            text-transform: uppercase;
        }

        .btn:hover {
            transform: scale(1.05);
            background: #ffaa33;
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* Upgrade Cards */
        #upgrade-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .upgrade-card {
            background: #222;
            border: 2px solid #444;
            padding: 20px;
            width: 220px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: white;
        }

        .upgrade-card:hover {
            background: #333;
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .upgrade-title {
            color: var(--primary);
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upgrade-desc {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.4;
        }

        /* Floating Damage Numbers (rendered via CSS for simplicity) */
        .floater {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 0 #000;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        .stat-row { margin: 5px 0; }
        .highlight { color: var(--accent); }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- HUD (Visible during gameplay) -->
        <div id="hud" class="hidden">
            <div id="hud-top-left" class="hud-panel">
                <div class="stat-row">HP: <span id="hp-display" class="highlight">100/100</span></div>
                <div class="stat-row">WAVE: <span id="wave-display">1</span></div>
            </div>

            <div id="xp-bar-container">
                <div id="xp-bar-fill"></div>
            </div>
            <div id="level-indicator">LVL 1</div>

            <div id="hud-top-right" class="hud-panel">
                <div class="stat-row">SCORE: <span id="score-display" class="highlight">0</span></div>
                <div class="stat-row">TIME: <span id="time-display">00:00</span></div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <h1>Meow Survivor</h1>
            <h2>Voxel Chaos Edition</h2>
            <p style="color:#aaa; margin-bottom: 30px; max-width: 400px; text-align: center;">
                WASD / Arrows to Move.<br>
                Auto-aim enabled.<br>
                Collect gems, level up, become the ultimate cat.
            </p>
            <button class="btn" onclick="game.start()">Start Run</button>
        </div>

        <!-- Level Up Screen -->
        <div id="levelup-screen" class="screen hidden">
            <h1 style="font-size: 3rem; color: var(--accent);">Level Up!</h1>
            <p style="color: white;">Choose an upgrade</p>
            <div id="upgrade-container">
                <!-- Cards injected via JS -->
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameover-screen" class="screen hidden">
            <h1 style="color: var(--danger);">Game Over</h1>
            <div class="hud-panel" style="margin-bottom: 30px; text-align: center;">
                <div class="stat-row">Survived: <span id="go-time" class="highlight"></span></div>
                <div class="stat-row">Level: <span id="go-level" class="highlight"></span></div>
                <div class="stat-row">Score: <span id="go-score" class="highlight"></span></div>
            </div>
            <button class="btn" onclick="game.restart()">Try Again</button>
        </div>

    </div>

    <script>
        // --- AUDIO SYSTEM (Simple Synth) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const sfx = {
            shoot: () => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400 + Math.random()*200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            hit: () => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            collect: () => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },
            levelup: () => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const now = audioCtx.currentTime;
                const gain = audioCtx.createGain();
                gain.gain.value = 0.1;
                gain.connect(audioCtx.destination);
                
                [440, 554, 659, 880].forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.2);
                });
            }
        };

        // --- GAME CONSTANTS & STATE ---
        const COLORS = {
            cat: 0xff9900,
            catStripe: 0xcc7700,
            grass: 0x222222,
            grid: 0x333333,
            enemy: 0xff3333,
            bullet: 0x00ffff,
            gem: 0x00ff00,
            coin: 0xffd700
        };

        let scene, camera, renderer;
        let player, enemies = [], bullets = [], particles = [], loot = [];
        let lastTime = 0;
        let keys = {};
        
        const gameState = {
            status: 'MENU', // MENU, PLAYING, PAUSED, GAMEOVER
            score: 0,
            time: 0,
            wave: 1,
            xp: 0,
            level: 1,
            nextLevelXp: 10,
            enemySpawnTimer: 0,
            enemySpawnRate: 1.5, // Seconds
        };

        const playerStats = {
            speed: 10,
            hp: 100,
            maxHp: 100,
            damage: 10,
            fireRate: 0.4, // Seconds between shots
            fireTimer: 0,
            projectiles: 1,
            projectileSpeed: 20,
            pickupRange: 5,
            bulletSize: 0.4
        };

        // --- THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            
            // Isometric Camera
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 30, 20); // High angle
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Floor Grid
            const gridHelper = new THREE.GridHelper(100, 50, COLORS.grid, COLORS.grid);
            scene.add(gridHelper);
            
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ color: COLORS.grass });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);

            // Resize handler
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- VOXEL BUILDERS ---
        function createVoxelCat() {
            const group = new THREE.Group();

            // Materials
            const bodyMat = new THREE.MeshStandardMaterial({ color: COLORS.cat });
            const stripeMat = new THREE.MeshStandardMaterial({ color: COLORS.catStripe });
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // Body
            const bodyGeo = new THREE.BoxGeometry(1, 1, 1.5);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.set(0, 1, 0.5);
            head.castShadow = true;
            group.add(head);

            // Ears
            const earGeo = new THREE.ConeGeometry(0.2, 0.4, 4);
            const earL = new THREE.Mesh(earGeo, stripeMat);
            earL.position.set(-0.3, 1.4, 0.5);
            earL.rotation.y = -0.5;
            const earR = new THREE.Mesh(earGeo, stripeMat);
            earR.position.set(0.3, 1.4, 0.5);
            earR.rotation.y = 0.5;
            group.add(earL, earR);

            // Tail
            const tailGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const tail = new THREE.Mesh(tailGeo, stripeMat);
            tail.position.set(0, 0.6, -0.8);
            tail.rotation.x = 0.5;
            group.add(tail);

            return group;
        }

        function createVoxelEnemy(type = 'slime') {
            const group = new THREE.Group();
            let color = type === 'slime' ? 0x55ff55 : 0xff3333;
            if(type === 'boss') color = 0x8800ff;

            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = 0.5;
            mesh.castShadow = true;
            
            if(type === 'boss') {
                mesh.scale.set(2,2,2);
                mesh.position.y = 1;
            }

            group.add(mesh);
            group.userData = { type: type, hp: type === 'boss' ? 50 : 10 };
            return group;
        }

        // --- GAME ENTITIES ---
        
        function spawnPlayer() {
            if (player) scene.remove(player);
            player = createVoxelCat();
            scene.add(player);
            playerStats.hp = playerStats.maxHp;
            gameState.xp = 0;
            gameState.level = 1;
            gameState.nextLevelXp = 10;
            gameState.time = 0;
            gameState.score = 0;
            
            // Reset Upgrades to base
            playerStats.speed = 10;
            playerStats.maxHp = 100;
            playerStats.damage = 10;
            playerStats.fireRate = 0.4;
            playerStats.projectiles = 1;
        }

        function spawnEnemy() {
            // Pick random position outside camera view but somewhat close
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 10; // 20-30 units away
            const x = player.position.x + Math.cos(angle) * radius;
            const z = player.position.z + Math.sin(angle) * radius;

            const isBoss = Math.random() < 0.05 && gameState.time > 60;
            const enemy = createVoxelEnemy(isBoss ? 'boss' : 'slime');
            enemy.position.set(x, 0, z);
            
            // Scaling difficulty
            const hpMulti = 1 + (gameState.time / 60);
            enemy.userData.hp = (isBoss ? 100 : 20) * hpMulti;
            enemy.userData.speed = (isBoss ? 3 : 4) + (gameState.time/120); 
            enemy.userData.damage = isBoss ? 20 : 10;
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createBullet(direction, offsetAngle = 0) {
            const geo = new THREE.BoxGeometry(playerStats.bulletSize, playerStats.bulletSize, playerStats.bulletSize);
            const mat = new THREE.MeshStandardMaterial({ 
                color: COLORS.bullet, 
                emissive: COLORS.bullet,
                emissiveIntensity: 0.8
            });
            const bullet = new THREE.Mesh(geo, mat);
            
            bullet.position.copy(player.position);
            bullet.position.y = 0.8; // Shoot from mouth height
            
            // Rotate direction
            const x = direction.x * Math.cos(offsetAngle) - direction.z * Math.sin(offsetAngle);
            const z = direction.x * Math.sin(offsetAngle) + direction.z * Math.cos(offsetAngle);
            
            bullet.userData = { velocity: new THREE.Vector3(x, 0, z).normalize().multiplyScalar(playerStats.projectileSpeed), life: 2 };
            scene.add(bullet);
            bullets.push(bullet);
            sfx.shoot();
        }

        function createParticle(pos, count = 5, color = 0xffffff) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.z += (Math.random() - 0.5);
                mesh.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function createLoot(pos, type='xp') {
            const geo = type === 'xp' ? new THREE.OctahedronGeometry(0.3) : new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const color = type === 'xp' ? COLORS.gem : COLORS.coin;
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y = 0.5;
            mesh.userData = { type: type, value: type==='xp'?10:50 };
            scene.add(mesh);
            loot.push(mesh);
        }

        // --- GAME LOGIC ---

        function updatePlayer(dt) {
            // Movement
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys['ArrowUp'] || keys['w']) moveDir.z -= 1;
            if (keys['ArrowDown'] || keys['s']) moveDir.z += 1;
            if (keys['ArrowLeft'] || keys['a']) moveDir.x -= 1;
            if (keys['ArrowRight'] || keys['d']) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.speed * dt);
                player.position.add(moveDir);
                player.lookAt(player.position.clone().add(moveDir));
                
                // Bobbing animation
                player.position.y = 0.5 + Math.sin(gameState.time * 15) * 0.1;
            }

            // Clamp to map bounds (optional, but good for safety)
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));

            // Camera Follow
            const targetPos = player.position.clone().add(new THREE.Vector3(20, 30, 20));
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);

            // Shooting
            playerStats.fireTimer -= dt;
            if (playerStats.fireTimer <= 0) {
                // Find nearest enemy
                let nearest = null;
                let minDist = 20; // Range
                
                for(let e of enemies) {
                    const d = player.position.distanceTo(e.position);
                    if(d < minDist) {
                        minDist = d;
                        nearest = e;
                    }
                }

                if (nearest) {
                    const dir = new THREE.Vector3().subVectors(nearest.position, player.position).normalize();
                    
                    // Multishot logic
                    if (playerStats.projectiles === 1) {
                        createBullet(dir);
                    } else {
                        const spread = 0.3; // Radians
                        const startAngle = -spread * (playerStats.projectiles - 1) / 2;
                        for(let i=0; i<playerStats.projectiles; i++) {
                            createBullet(dir, startAngle + (i * spread));
                        }
                    }
                    playerStats.fireTimer = playerStats.fireRate;
                }
            }
        }

        function updateEnemies(dt) {
            // Spawning
            gameState.enemySpawnTimer -= dt;
            if (gameState.enemySpawnTimer <= 0) {
                spawnEnemy();
                gameState.enemySpawnTimer = Math.max(0.2, gameState.enemySpawnRate - (gameState.time * 0.005));
            }

            // Movement & Collision
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                e.position.add(dir.multiplyScalar(e.userData.speed * dt));
                e.lookAt(player.position);

                // Player Collision
                if (e.position.distanceTo(player.position) < 1.0) {
                    playerStats.hp -= e.userData.damage * dt; // DPS
                    updateHUD();
                    if (playerStats.hp <= 0) gameOver();
                }
            }
        }

        function updateBullets(dt) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity.clone().multiplyScalar(dt));
                b.userData.life -= dt;

                if (b.userData.life <= 0) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                // Hit Detection
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.position.distanceTo(e.position) < 1.0) {
                        e.userData.hp -= playerStats.damage;
                        createParticle(e.position, 3, 0xff9900);
                        sfx.hit();

                        if (e.userData.hp <= 0) {
                            // Enemy Death
                            createParticle(e.position, 10, 0xff3333);
                            createLoot(e.position, Math.random() > 0.8 ? 'coin' : 'xp');
                            scene.remove(e);
                            enemies.splice(j, 1);
                            gameState.score += 100;
                        }

                        hit = true;
                        break; 
                    }
                }

                if (hit) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }
        }

        function updateLoot(dt) {
            for (let i = loot.length - 1; i >= 0; i--) {
                const l = loot[i];
                const dist = l.position.distanceTo(player.position);
                
                // Magnet
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(player.position, l.position).normalize();
                    l.position.add(dir.multiplyScalar(10 * dt)); // Fly fast to player
                    
                    if (dist < 1.0) {
                        // Collect
                        if (l.userData.type === 'xp') addXP(l.userData.value);
                        else gameState.score += l.userData.value;
                        
                        sfx.collect();
                        scene.remove(l);
                        loot.splice(i, 1);
                    }
                } else {
                    // Bobbing
                    l.rotation.y += dt;
                    l.position.y = 0.5 + Math.sin(Date.now() * 0.005) * 0.2;
                }
            }
        }

        function updateParticles(dt) {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel.clone().multiplyScalar(dt));
                p.userData.vel.y -= 9.8 * dt; // Gravity
                p.userData.life -= dt;
                p.scale.multiplyScalar(0.95); // Shrink

                if (p.position.y < 0) p.position.y = 0; // Floor collision

                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- PROGRESSION SYSTEM ---

        function addXP(amount) {
            gameState.xp += amount;
            if (gameState.xp >= gameState.nextLevelXp) {
                gameState.xp -= gameState.nextLevelXp;
                gameState.level++;
                gameState.nextLevelXp = Math.floor(gameState.nextLevelXp * 1.5);
                triggerLevelUp();
            }
            updateHUD();
        }

        function triggerLevelUp() {
    // 暫停遊戲邏輯，但畫面還在跑
    gameState.status = 'PAUSED';
    sfx.levelup();

    // 可選升級清單
    const options = [
        { 
            title: "Sharper Claws", 
            desc: "+20% Damage", 
            apply: () => { playerStats.damage *= 1.2; } 
        },
        { 
            title: "Zoomies", 
            desc: "+20% Movement Speed", 
            apply: () => { playerStats.speed *= 1.2; } 
        },
        { 
            title: "Rapid Fire", 
            desc: "+20% Attack Speed", 
            apply: () => { playerStats.fireRate *= 0.8; } 
        },
        { 
            title: "Extra Paw", 
            desc: "+1 Projectile", 
            apply: () => { playerStats.projectiles += 1; } 
        },
        { 
            title: "Thick Fur", 
            desc: "Heal 50% HP + Max HP Up", 
            apply: () => { 
                playerStats.maxHp += 20; 
                playerStats.hp = Math.min(
                    playerStats.hp + playerStats.maxHp / 2, 
                    playerStats.maxHp
                ); 
            } 
        },
        {
            title: "Magnet Whiskers",
            desc: "+50% Pickup Range",
            apply: () => { playerStats.pickupRange *= 1.5; }
        },
        {
            title: "Giant Spitball",
            desc: "Bigger Bullets +10% Dmg",
            apply: () => { 
                playerStats.bulletSize *= 1.2; 
                playerStats.damage *= 1.1; 
            }
        }
    ];

    // 產生 3 個隨機升級卡片
    const container = document.getElementById('upgrade-container');
    container.innerHTML = '';

    const shuffled = options
        .sort(() => 0.5 - Math.random())
        .slice(0, 3);

    shuffled.forEach(opt => {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `
            <div class="upgrade-title">${opt.title}</div>
            <div class="upgrade-desc">${opt.desc}</div>
        `;

        card.onclick = () => {
            // 套用升級效果
            opt.apply();

            // 關閉升級畫面，回到遊戲
            document
                .getElementById('levelup-screen')
                .classList.add('hidden');

            gameState.status = 'PLAYING';
            lastTime = performance.now(); // 避免 dt 突然變超大
            updateHUD();
            // （因為 animate 一直在跑，這行可以保留也可以刪掉）
            requestAnimationFrame(animate);
        };

        // ⭐ 把卡片真的加到畫面上
        container.appendChild(card);
    });

    // 顯示升級畫面
    document
        .getElementById('levelup-screen')
        .classList.remove('hidden');
}


        // --- UI UPDATES ---
        function updateHUD() {
            document.getElementById('hp-display').innerText = `${Math.floor(playerStats.hp)}/${Math.floor(playerStats.maxHp)}`;
            document.getElementById('score-display').innerText = gameState.score;
            document.getElementById('wave-display').innerText = Math.floor(gameState.time / 30) + 1;
            
            const xpPct = (gameState.xp / gameState.nextLevelXp) * 100;
            document.getElementById('xp-bar-fill').style.width = `${xpPct}%`;
            document.getElementById('level-indicator').innerText = `LVL ${gameState.level}`;
            
            const mins = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('time-display').innerText = `${mins}:${secs}`;
        }

        function gameOver() {
            gameState.status = 'GAMEOVER';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameover-screen').classList.remove('hidden');
            
            document.getElementById('go-time').innerText = document.getElementById('time-display').innerText;
            document.getElementById('go-level').innerText = gameState.level;
            document.getElementById('go-score').innerText = gameState.score;
        }

        // --- MAIN CONTROL ---
        const game = {
            start: () => {
                spawnPlayer();
                // Clear old entities
                enemies.forEach(e => scene.remove(e)); enemies = [];
                bullets.forEach(b => scene.remove(b)); bullets = [];
                loot.forEach(l => scene.remove(l)); loot = [];
                particles.forEach(p => scene.remove(p)); particles = [];

                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                
                gameState.status = 'PLAYING';
                lastTime = performance.now();
                animate(lastTime);
            },
            restart: () => {
                game.start();
            }
        };

        // --- INPUT LISTENERS ---
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        // --- ANIMATION LOOP ---
        function animate(now) {
    requestAnimationFrame(animate); // 先排下一幀

    if (gameState.status !== 'PLAYING') return; // 不在 PLAYING 就只是不更新遊戲邏輯

    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    gameState.time += dt;

    updatePlayer(dt);
    updateEnemies(dt);
    updateBullets(dt);
    updateLoot(dt);
    updateParticles(dt);
    
    updateHUD();
    renderer.render(scene, camera);
}

        // Initialize
        initThree();

    </script>
</body>
</html>


